# encoding: utf-8
# filename: monomial_ideal.pyx

"""
Monomial Ideals

This module is a high-performance implementation specifically for
monomial ideals over fields.

EXAMPLES::

    sage: R = PolynomialRing(QQ, ','.join('x'+str(i) for i in range(54)))
    sage: R.inject_variables()
    Defining x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, 
    x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, 
    x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, 
    x45, x46, x47, x48, x49, x50, x51, x52, x53
    sage: I = R.ideal([
    ....:     x0*x12 + x3*x13 + x6*x14 + x21*x27 + x22*x30 + x23*x33,
    ....:     x0*x15 + x3*x16 + x6*x17 + x24*x27 + x25*x30 + x26*x33, 
    ....:     x1*x9 + x4*x10 + x7*x11 + x18*x28 + x19*x31 + x20*x34, 
    ....:     x1*x15 + x4*x16 + x7*x17 + x24*x28 + x25*x31 + x26*x34, 
    ....:     x2*x9 + x5*x10 + x8*x11 + x18*x29 + x19*x32 + x20*x35, 
    ....:     x2*x12 + x5*x13 + x8*x14 + x21*x29 + x22*x32 + x23*x35, 
    ....:     x18*x30 + x21*x31 + x24*x32 + x39*x45 + x40*x48 + x41*x51, 
    ....:     x18*x33 + x21*x34 + x24*x35 + x42*x45 + x43*x48 + x44*x51, 
    ....:     x19*x27 + x22*x28 + x25*x29 + x36*x46 + x37*x49 + x38*x52, 
    ....:     x19*x33 + x22*x34 + x25*x35 + x42*x46 + x43*x49 + x44*x52, 
    ....:     x20*x27 + x23*x28 + x26*x29 + x36*x47 + x37*x50 + x38*x53, 
    ....:     x20*x30 + x23*x31 + x26*x32 + x39*x47 + x40*x50 + x41*x53,
    ....:     x0*x9 + x3*x10 + x6*x11 - x2*x15 - x5*x16 - x8*x17 + x18*x27 
    ....:         - x24*x29 + x19*x30 - x25*x32 + x20*x33 - x26*x35, 
    ....:     x1*x12 + x4*x13 + x7*x14 - x2*x15 - x5*x16 - x8*x17 + x21*x28
    ....:         - x24*x29 + x22*x31 - x25*x32 + x23*x34 - x26*x35, 
    ....:     x18*x27 + x21*x28 + x24*x29 - x20*x33 - x23*x34 - x26*x35 
    ....:         + x36*x45 - x42*x47 + x37*x48 - x43*x50 + x38*x51 - x44*x53, 
    ....:     x19*x30 + x22*x31 + x25*x32 - x20*x33 - x23*x34 - x26*x35 
    ....:         + x39*x46 - x42*x47 + x40*x49 - x43*x50 + x41*x52 - x44*x53])
    sage: leading_terms_ideal(I).Hilbert_series(deg_bound=5)
    1 + 54*t + 1469*t^2 + 26884*t^3 + 372808*t^4 + 4182440*t^5 + O(t^6)
"""

cimport cython


from sage.misc.cachefunc import cached_method
from sage.rings.all import QQ, PolynomialRing, PowerSeriesRing
from sage.structure.sage_object cimport SageObject
from sage.rings.big_oh import O


def leading_terms_ideal(ideal_generators, check_monomial=False):
    """
    Construct the monomial ideal of leading terms

    INPUT:

    - ``ideal_generators`` -- a list of ideal generators, or an ideal.

    - ``check_monomial`` -- boolean (default: ``False``). Whether to
      check that all given generators are already monomials.

    OUTPUT:

    The :class:`MonomialIdeal` generated by the leading terms of the
    ``ideal_generators``.
      
    .. note::
    
        This depends on the ideal generators unless the ideal
        generators are a Groebner basis.

    EXAMPLES::

        sage: R.<x,y,z> = QQ[]
        sage: I = R.ideal(x^2*y, x*y*z, y*z^2)
        sage: leading_terms_ideal(I)
        ideal(m(2, 1, 0), m(1, 1, 1), m(0, 1, 2))
    """
    try:
        ideal_generators = list(ideal_generators)
    except TypeError:
        ideal_generators = ideal_generators.gens()
    ring = ideal_generators[0].parent()
    cachemgr = CacheManager(ring.ngens())
    monomials = []
    for gen in ideal_generators:
        exponents = gen.exponents()
        if check_monomial and len(exponents) > 1:
            raise ValueError('not a monomial ideal')
        m = cachemgr.make_monomial(exponents[0])
        monomials.append(m)
    return cachemgr.make_ideal(monomials)



cdef inline bint divides(CacheManager cache, Monomial lhs, Monomial rhs):
    cdef long id_lhs = id(lhs)
    cdef long id_rhs = id(rhs)
    cache.divides_cache_call += 1
    try:
        return cache.divides_cache[(id_lhs, id_rhs)]
    except KeyError:
        pass
    cache.divides_cache_miss += 1
    cdef bint d = lhs.divides(rhs)
    cache.divides_cache[(id_lhs, id_rhs)] = d
    return d



@cython.profile(True)
cdef class CacheManager:

    # power series ring (initialized once)
    cdef object power_series_ring, variable

    # power series ring for refined Hilbert series (new for each call
    # to Hilbert_series)
    cdef public object refined_power_series_ring, refined_variable
    cdef public tuple refined_coeffs

    cdef int n_vars
    cdef dict monomials
    cdef list sorted_monomials

    cdef dict divided_by_gcd_cache
    cdef int divided_by_gcd_cache_call
    cdef int divided_by_gcd_cache_miss

    cdef dict divides_cache
    cdef int divides_cache_call
    cdef int divides_cache_miss

    def __init__(self, int n_variables):
        """
        Container for caches common to multiple :class:`MonomialIdeal`
        instances
        """
        # print 'initializing cache manager'
        self.n_vars = n_variables
        self.power_series_ring = PowerSeriesRing(QQ, 't')
        self.refined_power_series_ring = None
        self.variable = self.power_series_ring.gen(0)
        self.monomials = dict()
        self.sorted_monomials = list()
        self.divided_by_gcd_cache = dict()
        self.divided_by_gcd_cache_call = self.divided_by_gcd_cache_miss = 0
        self.divides_cache = dict()
        self.divides_cache_call = self.divides_cache_miss = 0

    def make_monomial(self, exponents):
        """
        Return the monomial with given exponents
        
        OUTPUT:

        A :class:`Monomial` with the given exponents. Might be a
        previously-constrcucted cached copy.

        EXAMPLES::

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3])
            sage: m2 = c.make_monomial([1,2,3])
            sage: m1 is m2
            True
        """
        exponents = tuple(map(int, exponents))
        try:
            return self.monomials[exponents]
        except KeyError:
            pass
        monomial = Monomial(exponents, self)
        self.monomials[exponents] = monomial
        self.sorted_monomials.append(monomial)
        self.sorted_monomials.sort()
        for i, m in enumerate(self.sorted_monomials):
            m.sort_rank = i
        return monomial

    def make_ideal(self, monomials):
        return MonomialIdeal(monomials, self)

    cdef Monomial divided_by_gcd(self, Monomial m1, Monomial m2):
        cdef long id_m1 = id(m1)
        cdef long id_m2 = id(m2)
        if id_m1 > id_m2:
            id_m1, id_m2 = id_m2, id_m1
        self.divided_by_gcd_cache_call += 1
        try:
            return self.divided_by_gcd_cache[(id_m1, id_m2)]
        except KeyError:
            pass
        self.divided_by_gcd_cache_miss += 1
        cdef Monomial quotient = m1.divided_by_gcd(m2)
        self.divided_by_gcd_cache[(id_m1, id_m2)] = quotient
        return quotient
            
    def print_stats(self):
        print 'monomial cache size: {0}'.format(len(self.monomials))
        print 'divided_by_gcd_cache: {0} calls, {1} cache misses, size {2}'.format(
            self.divided_by_gcd_cache_call, self.divided_by_gcd_cache_miss, 
            len(self.divided_by_gcd_cache))
        print 'divides_cache: {0} calls, {1} cache misses, size {2}'.format(
            self.divides_cache_call, self.divides_cache_miss, len(self.divides_cache))
        


@cython.profile(True)
cdef class Monomial:

    cdef CacheManager cache
    cdef public int n
    cdef public int tdeg
    cdef public int sort_rank
    cdef public int first_nonzero
    cdef public tuple exponents
    cdef int _hash 

    def __init__(self, exponents, CacheManager cache_manager):
        """
        Exponent vector of a monomial
        """
        self.cache = cache_manager
        self.exponents = exponents
        self.n = len(exponents)
        self.tdeg = sum(self.exponents)
        self.sort_rank = -1
        self._hash = hash(self.exponents)
        self.first_nonzero = self.n
        for i, e in enumerate(self.exponents):
            if e == 0:
                continue
            self.first_nonzero = i
            break

    def max_exponent(self):
        return max(self.exponents)

    def __repr__(self):
        return 'm'+repr(self.exponents)

    def __hash__(self):
        return self._hash

    def __cmp__(Monomial lhs, Monomial rhs):
        if lhs.sort_rank == -1 or rhs.sort_rank == -1:
            return lhs.compare(rhs)
        return cmp(lhs.sort_rank, rhs.sort_rank)

    cdef int compare(Monomial lhs, Monomial rhs):
        """
        Lexicographic order

        EXAMPLES::

            sage: R.<x,y,z> = QQ[]
            sage: I = R.ideal(x^2*y, x*y*z, y*z^2)
            sage: leading_terms_ideal(I)
            ideal(m(2, 1, 0), m(1, 1, 1), m(0, 1, 2))
        """
        cdef int i, l, r, c
        assert(lhs.n == rhs.n)
        for i in range(min(lhs.first_nonzero, rhs.first_nonzero), lhs.n):
            l = lhs.exponents[i]
            r = rhs.exponents[i]
            c = cmp(l,r)
            if c != 0:
                return -c
        return 0

    cpdef Monomial gcd(self, Monomial other):
        """
        Return the greatest common divisor
        
        EXAMPLES::
        
            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3]);  m1
            m(1, 2, 3)
            sage: m2 = c.make_monomial([3,2,1]);  m2
            m(3, 2, 1)
            sage: m1.gcd(m2)
            m(1, 2, 1)
        """
        cdef int i, x, y
        cdef int first_nonzero = min(self.first_nonzero, other.first_nonzero)
        cdef list result = [0] * first_nonzero
        assert(self.n == other.n)
        for i in range(first_nonzero, self.n):
            x = self.exponents[i]
            y = other.exponents[i]
            result.append(min(x, y))
        return self.cache.make_monomial(result)

    cpdef Monomial divided_by_gcd(self, Monomial other):
        """
        Return the quotient of ``self`` by the greatest common divisor
        
        EXAMPLES::
        
            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3]);  m1
            m(1, 2, 3)
            sage: m2 = c.make_monomial([3,2,1]);  m2
            m(3, 2, 1)
            sage: m1.gcd(m2)
            m(1, 2, 1)
            sage: m1.divided_by_gcd(m2)
            m(0, 0, 2)
        """
        cdef int i, x, y
        cdef int first_nonzero = min(self.first_nonzero, other.first_nonzero)
        cdef list result = [0] * first_nonzero
        assert(self.n == other.n)
        for i in range(first_nonzero, self.n):
            x = self.exponents[i]
            y = other.exponents[i]
            result.append(x - min(x, y))
        return self.cache.make_monomial(result)

    cpdef bint divides(Monomial self, Monomial other):
        """
        Return whether ``self`` divides ``other``

        EXAMPLES::

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3])
            sage: m2 = c.make_monomial([3,2,1])
            sage: m3 = c.make_monomial([1,2,1])
            sage: m1, m2, m3
            (m(1, 2, 3), m(3, 2, 1), m(1, 2, 1))
            sage: m1.divides(m1), m1.divides(m2), m1.divides(m3)
            (True, False, False)
            sage: m2.divides(m1), m2.divides(m2), m2.divides(m3)
            (False, True, False)
            sage: m3.divides(m1), m3.divides(m2), m3.divides(m3)
            (True, True, True)
        """
        cdef int i, x, y
        assert(self.n == other.n)
        for i in range(min(self.first_nonzero, other.first_nonzero), self.n):
            x = self.exponents[i]
            y = other.exponents[i]
            if x > y:
                return False
        return True
        

    def refined(self):
        """
        Return the contribution of the monomial to the refined Hilbert series
        
        This amounts to substituting the polyonmial ring variables
        with the given refinement, for example, characters under some
        group. You must call :meth:`~MonomialIdeal._init_refinement`
        before calling this method.

        EXAMPLES::
        
            sage: c = CacheManager(2)
            sage: m1 = c.make_monomial([3, 1])
            sage: m2 = c.make_monomial([2, 2])
            sage: m3 = c.make_monomial([1, 7])
            sage: i = c.make_ideal([m1, m2, m3])
            sage: R.<x,y> = QQ[]
            sage: i._init_refinement(10, [x, y])
            sage: m1.refined(), m2.refined(), m3.refined()
            (x^3*y, x^2*y^2, x*y^7)
        """
        result = self.cache.refined_power_series_ring.one()
        for i, e in enumerate(self.exponents):
            if e > 0:
                result *= self.cache.refined_coeffs[i] ** e
        return result



@cython.profile(True)
cdef class MonomialIdeal:

    cdef int n_vars
    cdef public tuple monomials
    cdef CacheManager cache
    cdef int _hash
    cdef object T, t

    def __init__(self, monomials, CacheManager cache_manager):
        """
        Monomial ideal over a field (no coefficients)
        """
        self.cache = cache_manager
        self.n_vars = cache_manager.n_vars
        self.monomials = tuple(sorted(monomials))
        assert(self.cache.n_vars == self.n_vars)
        self.T = self.cache.power_series_ring
        self.t = self.cache.variable
        
    def __repr__(self):
        return 'ideal'+repr(self.monomials)

    def __cmp__(self, other):
        """
        
        EXAMPLES::
        
            sage: c = CacheManager(2)
            sage: m1 = c.make_monomial([3, 1])
            sage: m2 = c.make_monomial([2, 2])
            sage: m3 = c.make_monomial([1, 7])
            sage: i = c.make_ideal([m1, m2, m3])
            sage: j = c.make_ideal([m1, m2, m3])
            sage: i.monomials == j.monomials
            True
            sage: cmp(i, j)
            0
        """
        return cmp(self.monomials, other.monomials)

    cpdef int ngens(self):
        return len(self.monomials)

    cpdef int nvariables(self):
        return self.n_vars

    def gens(self):
        return self.monomials

    def compressed(self):
        """
        Return a new ideal where all variables are actually used

        EXAMPLES::

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,0,3])
            sage: m2 = c.make_monomial([3,0,1])
            sage: i = c.make_ideal([m1, m2])
            sage: i.compressed()
            ideal(m(3, 1), m(1, 3))
        """
        used = set()
        for m in self.monomials:
            for i, e in enumerate(m.exponents):
                if e > 0:
                    used.update([i])
        used = tuple(used)
        return self.pick_variables(used)
         
    def pick_variables(self, variables):
        """
        Return a new ideal with a subset / permutation of variables

        INPUT:

        - ``variables`` -- list/tuple of integers.

        OUTPUT:

        A new and interrreduced ideal with the selected variables (and
        in that order). Variables of the ideal that are not listed in
        ``variables`` are effectively set to unity.

        Examples:

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,1,1])
            sage: m2 = c.make_monomial([0,2,2])
            sage: m3 = c.make_monomial([0,0,3])
            sage: i = c.make_ideal([m1, m2, m3]);  i
            ideal(m(1, 1, 1), m(0, 2, 2), m(0, 0, 3))
            sage: i.pick_variables([0, 1])
            ideal(m(0, 0),)
            sage: i.pick_variables([0, 2])
            ideal(m(1, 1), m(0, 2))
            sage: i.pick_variables([1, 2])
            ideal(m(1, 1), m(0, 3))
            sage: i.pick_variables([2, 1, 0])
            ideal(m(3, 0, 0), m(2, 2, 0), m(1, 1, 1))
       """
        cache_mgr = CacheManager(len(variables))
        if self.cache.refined_power_series_ring is not None:
            cache_mgr.refined_power_series_ring = self.cache.refined_power_series_ring
            cache_mgr.refined_variable = self.cache.refined_variable
            cache_mgr.refined_coeffs = tuple(self.cache.refined_coeffs[i] for i in variables)
        monomials = map(lambda m: cache_mgr.make_monomial([m.exponents[i] for i in variables]), 
                        self.monomials)
        ideal = cache_mgr.make_ideal(monomials)
        ideal.reduce()
        return ideal

    def divide_by(self, monomial):
        """
        Replace the ideal with its quotient by ``monomial``

        EXAMPLES::

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3])
            sage: m2 = c.make_monomial([3,2,1])
            sage: m3 = c.make_monomial([1,2,1])
            sage: i = c.make_ideal([m1, m2])
            sage: i
            ideal(m(3, 2, 1), m(1, 2, 3))
            sage: i.divide_by(m3)
            sage: i
            ideal(m(2, 0, 0), m(0, 0, 2))
        """
        self.monomials = tuple(sorted([self.cache.divided_by_gcd(m, monomial) 
                                       for m in self.monomials]))

    cpdef reduce(self):
        """
        Interreduce the generators

        EXAMPLES::

            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,3])
            sage: m2 = c.make_monomial([3,2,1])
            sage: m3 = c.make_monomial([1,2,1])
            sage: i = c.make_ideal([m1, m2, m3]);  i
            ideal(m(3, 2, 1), m(1, 2, 3), m(1, 2, 1))
            sage: i.reduce()
            sage: i
            ideal(m(1, 2, 1),)
        """
        cdef list reduced_basis = list()
        cdef int N = len(self.monomials)
        cdef bint divisible
        cdef Monomial m_i, m_j
        for i in range(N):
            m_i = self.monomials[i]
            divisible = False
            for j in range(i+1, N):  # only smaller monomials can divide
                m_j = self.monomials[j]
                #if self.cache.divides(m_j, m_i):
                if divides(self.cache, m_j, m_i):
                    divisible = True
                    break
            if not divisible:
                reduced_basis.append(m_i)
        self.monomials = tuple(sorted(reduced_basis))

    def remove_linear_generators(self):
        """
        Return a new ideal with the linear relations removed

        EXAMPLES::
        
            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,0])
            sage: m2 = c.make_monomial([0,0,1])
            sage: i = c.make_ideal([m1, m2]);  i
            ideal(m(1, 2, 0), m(0, 0, 1))
            sage: i.remove_linear_generators()
            (m(0, 0, 1),)
            sage: i
            ideal(m(1, 2, 0),)
       """
        cdef list linear = list()
        cdef list nonlinear = list()
        cdef Monomial m
        for m in self.monomials:
            if m.tdeg == 1:
                linear.append(m)
            else:
                nonlinear.append(m)
        self.monomials = tuple(sorted(nonlinear))
        return tuple(linear)

    def with_first_removed(self):
        """
        Return new ideal with first generator removed
        
        OUTPUT:
        
        A pair consisting of the first generator and the new ideal

        EXAMPLES::

        EXAMPLES::
        
            sage: c = CacheManager(3)
            sage: m1 = c.make_monomial([1,2,0])
            sage: m2 = c.make_monomial([0,0,1])
            sage: i = c.make_ideal([m1, m2]);  i
            ideal(m(1, 2, 0), m(0, 0, 1))
            sage: i.with_first_removed()
            (m(1, 2, 0), ideal(m(0, 0, 1),))
        """
        f = self.monomials[0]
        return f, self.cache.make_ideal(self.monomials[1:])

    def _init_refinement(self, deg_bound, refinement, name='t'):
        """
        Construct the powerseries ring for character-valued Hilbert series
        
        INPUT:
        
        - ``deg_bound`` -- integer. The highest power of the formal
          series variable to keep.
        
        - ``refinement`` -- a list of values (living in some ring) to
          replace the polynomial ring variables with.
          
        - ``name`` -- string, default: ``'t'``. The name of the formal
          power series variable.
          
        EXAMPLES::

            sage: c = CacheManager(2)
            sage: m = c.make_monomial([1, 3])
            sage: i = c.make_ideal([m])
            sage: R.<x,y> = QQ[]
            sage: i._init_refinement(10, [x, y])
            sage: c.refined_power_series_ring
            Power Series Ring in t over Multivariate Polynomial Ring in x, y over Rational Field
            sage: c.refined_variable.parent() is c.refined_power_series_ring
            True
            sage: c.refined_coeffs
            (x, y)
            sage: i.Hilbert_series_numerator(refine=[x, y])
            1 - x*y^3*t^4
        """
        from sage.structure.sequence import Sequence
        coeff_ring = Sequence(refinement).universe()
        ring = PowerSeriesRing(coeff_ring, name)
        ring.set_default_prec(deg_bound+1)
        self.cache.refined_power_series_ring = ring
        self.cache.refined_variable = ring.gen(0)
        self.cache.refined_coeffs = tuple(ring(x) for x in refinement)
        

    def Hilbert_series(self, deg_bound=5, name='t', output='powerseries', refine=None):
        """
        Return the Hilbert series

        EXAMPLES::

            sage: R = PolynomialRing(QQ, 'w,x,y,z')
            sage: w,x,y,z = R.gens()
            sage: ideal = R.ideal(x*y*z, x**2*y, y*z**2, x**3*y**3, w)
            sage: i = leading_terms_ideal(ideal)
            sage: print i.Hilbert_series(deg_bound=8)
            1 + 3*t + 6*t^2 + 7*t^3 + 8*t^4 + 9*t^5 + 10*t^6 + 11*t^7 + 12*t^8 + O(t^9)
        """
        cdef MonomialIdeal ideal
        if refine is None:
            ideal = self.compressed()
            ideal.T.set_default_prec(deg_bound+1)
            HS = ideal._Hilbert_series_recursion(deg_bound)
            return HS / (1-self.t)**self.n_vars
        else:
            self._init_refinement(deg_bound, refine, name)
            ideal = self.compressed()
            ideal.T.set_default_prec(deg_bound+1)
            HS = ideal._refined_Hilbert_series_recursion(deg_bound)
            T = self.cache.refined_power_series_ring
            t = self.cache.refined_variable
            denominator = T.one() + O(t ** (deg_bound+1))
            for var in range(self.n_vars):
                denominator *= 1 - self.cache.refined_coeffs[var] * t
            return HS / denominator
            
        
    def Hilbert_series_numerator(self, deg_bound=5, name='t', output='powerseries', refine=None):
        """
        Return the numerator of the Hilbert series
        
        OUTPUT:
        
        The numerator $P(t)$ of $HS(t) = P(t) / (1-t)^n$, where $n$ is the
        number of variables in the polynomial ring.

        EXAMPLES::

            sage: R = PolynomialRing(QQ, 'w,x,y,z')
            sage: w,x,y,z = R.gens()
            sage: ideal = R.ideal(x*y*z, x**2*y, y*z**2, x**3*y**3, w)
            sage: i = leading_terms_ideal(ideal)
            sage: i.Hilbert_series(deg_bound=8)
            1 + 3*t + 6*t^2 + 7*t^3 + 8*t^4 + 9*t^5 + 10*t^6 + 11*t^7 + 12*t^8 + O(t^9)
            sage: i.Hilbert_series_numerator(deg_bound=8)
            1 - t - 3*t^3 + 5*t^4 - 2*t^5
        """
        cdef MonomialIdeal ideal
        if refine is None:
            ideal = self.compressed()
            ideal.T.set_default_prec(deg_bound+1)
            return ideal._Hilbert_series_recursion(deg_bound)
        else:
            self._init_refinement(deg_bound, refine, name)
            ideal = self.compressed()
            return ideal._refined_Hilbert_series_recursion(deg_bound)

    cpdef _Hilbert_series_recursion(MonomialIdeal self, int deg_bound):
        r"""
        Recursively compute the Hilbert series
        
        OUPUT:
        
        The numerator $P(t)$ of $HS(t) = P(t) / (1-t)^n$, where $n$ is the
        number of variables in the polynomial ring.

        EXAMPLES::
        
            sage: c = CacheManager(2)
            sage: m1 = c.make_monomial([3, 1])
            sage: m2 = c.make_monomial([2, 2])
            sage: m3 = c.make_monomial([1, 7])
            sage: i = c.make_ideal([m1, m2, m3])
            sage: i._Hilbert_series_recursion(10)
            1 - 2*t^4 + t^5 - t^8 + t^9
        """
        if self.ngens() == 0 or deg_bound <= 0:
            return self.T.one()
        f, ideal = self.with_first_removed()
        t = self.t
        if ideal.ngens() == 0:
            if deg_bound < f.tdeg:
                return self.T.one()
            else:
                return self.T.one() - t ** f.tdeg
        HS_remaining = ideal._Hilbert_series_recursion(deg_bound)

        #print f
        #return HS_remaining

        if deg_bound <= f.tdeg:
            return HS_remaining - t ** f.tdeg
        ideal.divide_by(f)
        ideal.reduce()
    
        ### We could wrap things up now, but we will implement the step A below
        # HS_J = ideal._Hilbert_series_recursion(deg_bound - f.tdeg)
        # return HS_remaining - t ** f.tdeg * HS_J
        
        linear = ideal.remove_linear_generators()
        n_linear = len(set(linear))
        HS_J = ideal._Hilbert_series_recursion(deg_bound - f.tdeg)
        return HS_remaining - t ** f.tdeg * HS_J * (1 - t) ** n_linear
        
    
    cpdef _refined_Hilbert_series_recursion(MonomialIdeal self, int deg_bound):
        r"""
        Recursively compute the refined Hilbert series
        
        OUPUT:
        
        Same as :meth:`_Hilbert_series_recursion`, but as a power
        series with coeficients in a larger ring than $\QQ$.v

        EXAMPLES::
        
            sage: c = CacheManager(2)
            sage: m1 = c.make_monomial([3, 1])
            sage: m2 = c.make_monomial([2, 2])
            sage: m3 = c.make_monomial([1, 7])
            sage: i = c.make_ideal([m1, m2, m3])
            sage: R.<x,y> = QQ[]
            sage: i._init_refinement(10, [x, y])
            sage: i._refined_Hilbert_series_recursion(10)
            1 + (-x^3*y - x^2*y^2)*t^4 + x^3*y^2*t^5 - x*y^7*t^8 + x^2*y^7*t^9

            sage: i.Hilbert_series(deg_bound=5, refine=[x, y])
            1 + (x + y)*t + (x^2 + x*y + y^2)*t^2 + (x^3 + x^2*y + x*y^2 + y^3)*t^3 
            + (x^4 + x*y^3 + y^4)*t^4 + (x^5 + x*y^4 + y^5)*t^5 + O(t^6)
        """
        T = self.cache.refined_power_series_ring
        t = self.cache.refined_variable
        if self.ngens() == 0 or deg_bound <= 0:
            return T.one()
        f, ideal = self.with_first_removed()
        if ideal.ngens() == 0:
            if deg_bound < f.tdeg:
                return T.one()
            else:
                return T.one() - f.refined() * (t ** f.tdeg)
        HS_remaining = ideal._refined_Hilbert_series_recursion(deg_bound)

        #print f
        #return HS_remaining

        if deg_bound <= f.tdeg:
            return HS_remaining - f.refined() * (t ** f.tdeg)
        ideal.divide_by(f)
        ideal.reduce()
    
        ### We could wrap things up now, but we will implement the step A below
        # HS_J = ideal._Hilbert_series_recursion(deg_bound - f.tdeg)
        # return HS_remaining - t ** f.tdeg * HS_J
        
        linear = ideal.remove_linear_generators()
        linear_contrib = T.one()
        for var in linear:
            linear_contrib *= 1 - var.refined() * t
        HS_J = ideal._refined_Hilbert_series_recursion(deg_bound - f.tdeg)
        return HS_remaining - f.refined() * (t ** f.tdeg) * HS_J * linear_contrib



def example(deg_bound=5):
    R = PolynomialRing(QQ, ','.join('x'+str(i) for i in range(54)))
    x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, \
    x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, \
    x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, \
    x45, x46, x47, x48, x49, x50, x51, x52, x53 = R.gens()
    I = R.ideal([
            x0*x12 + x3*x13 + x6*x14 + x21*x27 + x22*x30 + x23*x33,
            x0*x15 + x3*x16 + x6*x17 + x24*x27 + x25*x30 + x26*x33, 
            x1*x9 + x4*x10 + x7*x11 + x18*x28 + x19*x31 + x20*x34, 
            x1*x15 + x4*x16 + x7*x17 + x24*x28 + x25*x31 + x26*x34, 
            x2*x9 + x5*x10 + x8*x11 + x18*x29 + x19*x32 + x20*x35, 
            x2*x12 + x5*x13 + x8*x14 + x21*x29 + x22*x32 + x23*x35, 
            x18*x30 + x21*x31 + x24*x32 + x39*x45 + x40*x48 + x41*x51, 
            x18*x33 + x21*x34 + x24*x35 + x42*x45 + x43*x48 + x44*x51, 
            x19*x27 + x22*x28 + x25*x29 + x36*x46 + x37*x49 + x38*x52, 
            x19*x33 + x22*x34 + x25*x35 + x42*x46 + x43*x49 + x44*x52, 
            x20*x27 + x23*x28 + x26*x29 + x36*x47 + x37*x50 + x38*x53, 
            x20*x30 + x23*x31 + x26*x32 + x39*x47 + x40*x50 + x41*x53,
            x0*x9 + x3*x10 + x6*x11 - x2*x15 - x5*x16 - x8*x17 + x18*x27 
            - x24*x29 + x19*x30 - x25*x32 + x20*x33 - x26*x35, 
            x1*x12 + x4*x13 + x7*x14 - x2*x15 - x5*x16 - x8*x17 + x21*x28
            - x24*x29 + x22*x31 - x25*x32 + x23*x34 - x26*x35, 
            x18*x27 + x21*x28 + x24*x29 - x20*x33 - x23*x34 - x26*x35 
            + x36*x45 - x42*x47 + x37*x48 - x43*x50 + x38*x51 - x44*x53, 
            x19*x30 + x22*x31 + x25*x32 - x20*x33 - x23*x34 - x26*x35 
            + x39*x46 - x42*x47 + x40*x49 - x43*x50 + x41*x52 - x44*x53])
    gb = I.groebner_basis(deg_bound=deg_bound)
    return leading_terms_ideal(gb)


def example_graph(deg_bound=5):
    ideal = example(deg_bound)
    from sage.graphs.graph import Graph
    g = Graph(ideal.nvariables())
    for m in ideal.monomials:
        for i in range(ideal.nvariables()):
            for j in range(i):
                if m.exponents[i] != 0 and m.exponents[j] != 0:
                    g.add_edge(i, j)
    return g
                           
        


def run_example(deg_bound=5):
    """
    The $E_6$ theory Higgs-branch F-flat space
    """
    R = PolynomialRing(QQ, ','.join('x'+str(i) for i in range(54)))
    x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, \
    x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28, x29, \
    x30, x31, x32, x33, x34, x35, x36, x37, x38, x39, x40, x41, x42, x43, x44, \
    x45, x46, x47, x48, x49, x50, x51, x52, x53 = R.gens()
    I = R.ideal([
            x0*x12 + x3*x13 + x6*x14 + x21*x27 + x22*x30 + x23*x33,
            x0*x15 + x3*x16 + x6*x17 + x24*x27 + x25*x30 + x26*x33, 
            x1*x9 + x4*x10 + x7*x11 + x18*x28 + x19*x31 + x20*x34, 
            x1*x15 + x4*x16 + x7*x17 + x24*x28 + x25*x31 + x26*x34, 
            x2*x9 + x5*x10 + x8*x11 + x18*x29 + x19*x32 + x20*x35, 
            x2*x12 + x5*x13 + x8*x14 + x21*x29 + x22*x32 + x23*x35, 
            x18*x30 + x21*x31 + x24*x32 + x39*x45 + x40*x48 + x41*x51, 
            x18*x33 + x21*x34 + x24*x35 + x42*x45 + x43*x48 + x44*x51, 
            x19*x27 + x22*x28 + x25*x29 + x36*x46 + x37*x49 + x38*x52, 
            x19*x33 + x22*x34 + x25*x35 + x42*x46 + x43*x49 + x44*x52, 
            x20*x27 + x23*x28 + x26*x29 + x36*x47 + x37*x50 + x38*x53, 
            x20*x30 + x23*x31 + x26*x32 + x39*x47 + x40*x50 + x41*x53,
            x0*x9 + x3*x10 + x6*x11 - x2*x15 - x5*x16 - x8*x17 + x18*x27 
            - x24*x29 + x19*x30 - x25*x32 + x20*x33 - x26*x35, 
            x1*x12 + x4*x13 + x7*x14 - x2*x15 - x5*x16 - x8*x17 + x21*x28
            - x24*x29 + x22*x31 - x25*x32 + x23*x34 - x26*x35, 
            x18*x27 + x21*x28 + x24*x29 - x20*x33 - x23*x34 - x26*x35 
            + x36*x45 - x42*x47 + x37*x48 - x43*x50 + x38*x51 - x44*x53, 
            x19*x30 + x22*x31 + x25*x32 - x20*x33 - x23*x34 - x26*x35 
            + x39*x46 - x42*x47 + x40*x49 - x43*x50 + x41*x52 - x44*x53])
    gb = I.groebner_basis(deg_bound=deg_bound)
    cdef MonomialIdeal MI = leading_terms_ideal(gb)
    HS = MI.Hilbert_series(deg_bound=deg_bound)
    print HS
    t = HS.parent().gen(0)
    from sage.rings.big_oh import O
    result = 1 + 54*t + 1469*t**2 + 26856*t**3 + 371370*t**4 \
        + 4145076*t**5 + 38914954*t**6 + 316189224*t**7 + O(t**8)
    MI.cache.print_stats()
    return HS + O(t ** deg_bound) == result + O(t ** deg_bound)

    # return HS == 1 + 54*t + 1469*t**2 + 26884*t**3 + 372808*t**4 + 4182440*t**5 + O(t**6)


# print 'correct:', run_example()


def test_refined_example(deg_bound=5):
    """
    EXAMPLES::

        sage: test_refined_example()
        1 + (-z0^2*z1 - z0*z1^2 - z0^2*z2 - 2*z0*z1*z2 - z1^2*z2 - z0*z2^2 
        - z1*z2^2)*t^2 + (z0^3*z1*z2 + z0^2*z1^2*z2 + z0*z1^3*z2 + z0^2*z1*z2^2 
        + z0*z1^2*z2^2 + z0*z1*z2^3 + z0^2*z1^2 + z0^2*z1*z2 + z0*z1^2*z2 + z0^2*z2^2 
        + z0*z1*z2^2 + z1^2*z2^2)*t^3 + (-z0^3*z1^3*z2^3 - z0^4*z1^2*z2^2 
        - z0^3*z1^3*z2^2 - z0^2*z1^4*z2^2 - z0^3*z1^2*z2^3 - z0^2*z1^3*z2^3 
        - z0^2*z1^2*z2^4 - z0^3*z1^3*z2 - z0^3*z1^2*z2^2 - z0^2*z1^3*z2^2 
        - z0^3*z1*z2^3 - z0^2*z1^2*z2^3 - z0*z1^3*z2^3 - z0^2*z1^2*z2^2)*t^5 
        + (z0^4*z1^3*z2^3 + z0^3*z1^4*z2^3 + z0^3*z1^3*z2^4 + z0^4*z1^3*z2^2 
        + z0^3*z1^4*z2^2 + z0^4*z1^2*z2^3 + 2*z0^3*z1^3*z2^3 + z0^2*z1^4*z2^3 
        + z0^3*z1^2*z2^4 + z0^2*z1^3*z2^4 + z0^3*z1^3*z2^2 + z0^3*z1^2*z2^3 
        + z0^2*z1^3*z2^3)*t^6 + (-z0^4*z1^4*z2^3 - z0^4*z1^3*z2^4 - z0^3*z1^4*z2^4 
        - z0^4*z1^3*z2^3 - z0^3*z1^4*z2^3 - z0^3*z1^3*z2^4)*t^7 + z0^4*z1^4*z2^4*t^8
    """
    R = PolynomialRing(QQ, 'Q_00, Q_10, Q_20, Qt_00, Qt_01, Qt_02')
    Q_00, Q_10, Q_20, Qt_00, Qt_01, Qt_02 = R.gens()
    F = R.ideal(Qt_00*Q_00 - Qt_02*Q_20, 
                Qt_00*Q_10, Qt_00*Q_20, 
                Qt_01*Q_00, Qt_01*Q_10 - Qt_02*Q_20, 
                Qt_01*Q_20, Qt_02*Q_00, Qt_02*Q_10)
    Z = PolynomialRing(QQ, 'z0, z1, z2')
    z0, z1, z2 = Z.gens()
    action = [z1*z2, z0*z2, z0*z1, z0, z1, z2]
    ideal = leading_terms_ideal(F.groebner_basis(deg_bound=deg_bound))
    return ideal.Hilbert_series_numerator(deg_bound=deg_bound, refine=action)



def E6_invariants(deg_bound=4):
    """
    Higgs branch of the E6-theory (2 local SU(3), 2 global SU(3))

    EXAMPLES::
    
        sage: hs = E6_invariants(deg_bound=3)
        sage: t = hs.parent().gen(0)
        
    """
    R = PolynomialRing(QQ, 'Q1t01_00, Q1t01_01, Q1t01_02, Q1t01_10, Q1t01_11, ' +
                       'Q1t01_12, Q1t01_20, Q1t01_21, Q1t01_22, Q110_00, Q110_01, ' +
                       'Q110_02, Q110_10, Q110_11, Q110_12, Q110_20, Q110_21, Q110_22, '+
                       'Q2t12_00, Q2t12_01, Q2t12_02, Q2t12_10, Q2t12_11, Q2t12_12, '+
                       'Q2t12_20, Q2t12_21, Q2t12_22, Q221_00, Q221_01, Q221_02, Q221_10, '+
                       'Q221_11, Q221_12, Q221_20, Q221_21, Q221_22, Q3t23_00, Q3t23_01, '+
                       'Q3t23_02, Q3t23_10, Q3t23_11, Q3t23_12, Q3t23_20, Q3t23_21, '+
                       'Q3t23_22, Q332_00, Q332_01, Q332_02, Q332_10, Q332_11, '+
                       'Q332_12, Q332_20, Q332_21, Q332_22')
    Q1t01_00, Q1t01_01, Q1t01_02, Q1t01_10, Q1t01_11, Q1t01_12, Q1t01_20, Q1t01_21, \
        Q1t01_22, Q110_00, Q110_01, Q110_02, Q110_10, Q110_11, Q110_12, Q110_20, Q110_21, \
        Q110_22, Q2t12_00, Q2t12_01, Q2t12_02, Q2t12_10, Q2t12_11, Q2t12_12, Q2t12_20, \
        Q2t12_21, Q2t12_22, Q221_00, Q221_01, Q221_02, Q221_10, Q221_11, Q221_12, Q221_20, \
        Q221_21, Q221_22, Q3t23_00, Q3t23_01, Q3t23_02, Q3t23_10, Q3t23_11, Q3t23_12, \
        Q3t23_20, Q3t23_21, Q3t23_22, Q332_00, Q332_01, Q332_02, Q332_10, Q332_11, \
        Q332_12, Q332_20, Q332_21, Q332_22 = R.gens()
    F = R.ideal([
            Q1t01_00*Q110_00 + Q1t01_10*Q110_01 + Q1t01_20*Q110_02 - Q1t01_02*Q110_20 
            - Q1t01_12*Q110_21 - Q1t01_22*Q110_22 + Q2t12_00*Q221_00 - Q2t12_20*Q221_02 
            + Q2t12_01*Q221_10 - Q2t12_21*Q221_12 + Q2t12_02*Q221_20 
            - Q2t12_22*Q221_22, 
            Q1t01_00*Q110_10 + Q1t01_10*Q110_11 + Q1t01_20*Q110_12 + Q2t12_10*Q221_00 
            + Q2t12_11*Q221_10 + Q2t12_12*Q221_20, Q1t01_00*Q110_20 + Q1t01_10*Q110_21 
            + Q1t01_20*Q110_22 + Q2t12_20*Q221_00 + Q2t12_21*Q221_10 + Q2t12_22*Q221_20,
            Q1t01_01*Q110_00 + Q1t01_11*Q110_01 + Q1t01_21*Q110_02 + Q2t12_00*Q221_01 
            + Q2t12_01*Q221_11 + Q2t12_02*Q221_21, Q1t01_01*Q110_10 + Q1t01_11*Q110_11 
            + Q1t01_21*Q110_12 - Q1t01_02*Q110_20 - Q1t01_12*Q110_21 - Q1t01_22*Q110_22 
            + Q2t12_10*Q221_01 - Q2t12_20*Q221_02 + Q2t12_11*Q221_11 - Q2t12_21*Q221_12 
            + Q2t12_12*Q221_21 - Q2t12_22*Q221_22, Q1t01_01*Q110_20 + Q1t01_11*Q110_21
            + Q1t01_21*Q110_22 + Q2t12_20*Q221_01 + Q2t12_21*Q221_11 + Q2t12_22*Q221_21,
            Q1t01_02*Q110_00 + Q1t01_12*Q110_01 + Q1t01_22*Q110_02 + Q2t12_00*Q221_02 
            + Q2t12_01*Q221_12 + Q2t12_02*Q221_22, Q1t01_02*Q110_10 + Q1t01_12*Q110_11 
            + Q1t01_22*Q110_12 + Q2t12_10*Q221_02 + Q2t12_11*Q221_12 + Q2t12_12*Q221_22,
            Q2t12_00*Q221_00 + Q2t12_10*Q221_01 + Q2t12_20*Q221_02 - Q2t12_02*Q221_20 
            - Q2t12_12*Q221_21 - Q2t12_22*Q221_22 + Q3t23_00*Q332_00 - Q3t23_20*Q332_02 
            + Q3t23_01*Q332_10 - Q3t23_21*Q332_12 + Q3t23_02*Q332_20 - Q3t23_22*Q332_22, 
            Q2t12_00*Q221_10 + Q2t12_10*Q221_11 + Q2t12_20*Q221_12 + Q3t23_10*Q332_00 
            + Q3t23_11*Q332_10 + Q3t23_12*Q332_20, Q2t12_00*Q221_20 + Q2t12_10*Q221_21 
            + Q2t12_20*Q221_22 + Q3t23_20*Q332_00 + Q3t23_21*Q332_10 + Q3t23_22*Q332_20, 
            Q2t12_01*Q221_00 + Q2t12_11*Q221_01 + Q2t12_21*Q221_02 + Q3t23_00*Q332_01 
            + Q3t23_01*Q332_11 + Q3t23_02*Q332_21, Q2t12_01*Q221_10 + Q2t12_11*Q221_11 
            + Q2t12_21*Q221_12 - Q2t12_02*Q221_20 - Q2t12_12*Q221_21 - Q2t12_22*Q221_22 
            + Q3t23_10*Q332_01 - Q3t23_20*Q332_02 + Q3t23_11*Q332_11 - Q3t23_21*Q332_12 
            + Q3t23_12*Q332_21 - Q3t23_22*Q332_22, Q2t12_01*Q221_20 + Q2t12_11*Q221_21 
            + Q2t12_21*Q221_22 + Q3t23_20*Q332_01 + Q3t23_21*Q332_11 + Q3t23_22*Q332_21, 
            Q2t12_02*Q221_00 + Q2t12_12*Q221_01 + Q2t12_22*Q221_02 + Q3t23_00*Q332_02 
            + Q3t23_01*Q332_12 + Q3t23_02*Q332_22, Q2t12_02*Q221_10 + Q2t12_12*Q221_11 
            + Q2t12_22*Q221_12 + Q3t23_10*Q332_02 + Q3t23_11*Q332_12 + Q3t23_12*Q332_22
            ])
    Z = PolynomialRing(QQ, 'x0, x1, x2, y0, y1, y2')
    x0, x1, x2, y0, y1, y2 = Z.gens()
    action = [x0,
              x1,
              x2,
              x0,
              x1,
              x2,
              x0,
              x1,
              x2,
              x1*x2,
              x1*x2,
              x1*x2,
              x0*x2,
              x0*x2,
              x0*x2,
              x0*x1,
              x0*x1,
              x0*x1,
              x1*x2*y0,
              x1*x2*y1,
              x1*x2*y2,
              x0*x2*y0,
              x0*x2*y1,
              x0*x2*y2,
              x0*x1*y0,
              x0*x1*y1,
              x0*x1*y2,
              x0*y1*y2,
              x1*y1*y2,
              x2*y1*y2,
              x0*y0*y2,
              x1*y0*y2,
              x2*y0*y2,
              x0*y0*y1,
              x1*y0*y1,
              x2*y0*y1,
              y1*y2,
              y1*y2,
              y1*y2,
              y0*y2,
              y0*y2,
              y0*y2,
              y0*y1,
              y0*y1,
              y0*y1,
              y0,
              y1,
              y2,
              y0,
              y1,
              y2,
              y0,
              y1,
              y2]
    ideal = leading_terms_ideal(F.groebner_basis(deg_bound=deg_bound))
    # return ideal.Hilbert_series(deg_bound=deg_bound)   # unrefined
    ideal.Hilbert_series_numerator(deg_bound=deg_bound)
    from sage.rings.big_oh import O
    #return ideal.Hilbert_series_numerator(deg_bound=deg_bound, refine=action)
    HS = ideal.Hilbert_series(deg_bound=deg_bound, refine=action)
    return HS + O(HS.parent().gen(0) ** (deg_bound+1))


# print E6_invariants(deg_bound=2)


#hs = E6_invariants(deg_bound=4)
#r = UnitaryRepresentation(hs.coefficients()[4])
#r.special_invariants(z1_0, z1_1, z1_2).special_invariants(z2_0, z2_1, z2_2)
# 1 + 19*t^2 + 24*t^3 + 243*t^4 + 492*t^5 + O(t^6)
